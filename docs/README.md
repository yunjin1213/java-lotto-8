## 설계 고민
- 객체간의 종속성을 줄이는 방향
- 객체의 기능과 책임을 어떻게 나눌 것인가..
  - 되도록이면 하나의 객체는 하나의 책임을!
  - 정보를 많이 알고 있는 객체가 행위를!
  - 직접 가져와서 쓰지 말고 요청을!

validator를 따로 빼서 클래스로 갖고 있어야하나..
그런데 그럼 검증은 정보를 가지고 있는 객체가 하기로 한 원칙을 위배해야 하는데..

* 참고 코드 = mjucraft -> recruit / 김영한 app config    

## 흐름 정리
1. [Input]: 구입 금액 입력 -> [User] 전달
2. [User]: 로또 개수 확정, 
3. 각 로또의 번호 확정
4. 당첨 번호 입력
5. 보너스 번호 입력
6. 당첨 여부 확정
7. 수익률 계산

## 기능 정리
1. 금액 -> 개수
2. 랜덤 넘버 생성: random number creator
3. 당첨 넘버 생성
4. [ 로또 넘버 <-> 당첨 넘버 체크 ] -> 각 당첨 등수별 개수
5. 각 당첨 등수 개수 -> 금액
6. 수익률 계산
7. Error 발생

## 객체 정리
### 1. Lotto
   - 번호 6개
   - 번호 검증 함수(개수, 중복)
   - 번호 일치 함수(순서 무관)


### 2. WinningLotto
   - 번호 6개 + 보너스 1개
   - 번호 검증 함수(중복)


### 3. User
   - 총 사용 금액
   - 로또들
   - 총 당첨 금액


### 4. LottoBox
   - 랜덤 넘버 생성
   - 위닝 로또

### 5. Input / Output
   - 입력과 출력만 담당
   - 그 이상의 책임을 가지지 않는다.

## 고민 포인트
1. receipt는 로또 개수, 사용한 금액, 수익률, 상금등을 갖고만 있을건데 금액 -> 개수, 상금 + 사용한 금액 -> 수익률 이런 기능들은 누가 하고, 검증은 누가 해야 하지??
2. Lotto
3. User 하위에 Receipt와 Lotteries를 둬서 자연스럽게 하고 싶었는데 그렇게 하는 의미가 없어졌어..
4. 로또 번호들을 가질 Lotto가 번호를 검증해야 하는건 맞는데.. 중복 있으면 다시 요청해야 하잖아. 그걸 서비스에서 다 하는게 적절해 보이지 않아.
5. 즉, 현재의 문제
   -  로또 금액 검증을 책임질 객체가 없다.
     - 원래 원칙은 가지고 있는 Receipt인데 직관적으로 봐도 너무 이상하다. 
       얘는 그냥 값을 가져야 하는 애인데..
     - 그렇다고 service가 가지는 것도 이상해. 
       Calculator도 이상해.
   - 검증을 정보를 가진 객체가 한다고 하자. 그럼 생성하는 애가 잘못된 애를 주면, 정보 주체는 검증 -> 다시 생성 주체 호출 -> 값 받기 이 과정을 반복해야 하는 것인가.
6. 결론: 생성 객체도 검증의 책임을 져야 한다.
   - 근데 그럼 사용자가 입력하는 금액의 생성 객체는 Input인데 걔가 검증을 들고 있나?

7. Service의 createLotteries는 금액 -> 개수 -> 로또 발급 + Receipt 작성까지 해야 하는데 
   service의 구조상, 함수는 하나의 결과값을 return해줘야 하는데 List<Lotto>를 return 해주고 나면,
   Receipt 작성은 어떻게 하는가? 함수를 또 따로 빼기엔 너무 구조가 겹치는데?
   뿐만 아니라 추후에 상금과 수익률을 넣어주는 것도 문제다.
   지금 구조에선, Receipt -> 상금, 수익률 계산 함수 -> 계산 -> 새로운 Receipt 기존의 정보 넣어서 생성 
   -> 상금, 수익률 입력 -> 다시 return ; 미친 프로세스를 해야한다.
   

8. 해결 방법
   - User 만들자. 그래서 하위에 Receipt, Result, Lotteries를 다 가지고 있자.
   그래서 createLotteries에 User를 만들어 버리자. Result는 걍 초기화정도만 하고..
   - createLotteries를 더 쪼개는 방법.
     - calculateAmountOfLotteriesWithMoney: 돈 -> 개수
     - createLotteriesWithAmount: 개수 -> 로또 생성
   - 최종 해결 방법: 
     - 우선 Receipt와 Result를 쪼개야 한다.
     - createLotteries도 더 쪼개야 한다. createReceipt & createLotteries
     - 그럼 이제 문제는 createLotteries를 할 때 Receipt을 줘서 할 것인가?
       아니면, Receipt의 개수(int, Receipt.getLotteriesAmount())만 떼어 줄 것인가? 
       둘 다 문제가 있다. Receipt은 몰라도 되는 정보를 주고, 종속성에 문제가 생기고,
       개수를 주는 건, 나중에 컨트롤러에서 service의 함수에다가 Receipt.get~~를 써야한다.
     - 결론: 아무리 컨트롤러에서 get하는게 적절해 보이지 않아도 Receipt를 넘기는 건 좀...

9. 각 등수별 로또의 개수를 어떻게 저장하고 누가 정리할 것인가?
   - 각 로또들이 등수를 계산해서 내는 건 말이 안돼. 얘가 너무 많은 책임을 가져. 
     그럼 그냥 매칭 개수 정도만 return 해줄텐데.. 누군가는 이 정보들을 정리해야 돼.
     service는 안돼. calculator가 하기에도 좀 그래..
   - 정보 정리는?? 그냥 리스트로 하기엔 각 인덱스가 몇등을 의미하는지 알기가 어렵다...
     물론 그건 규칙으로 만들 수 있지만 그리 직관적이지도 않고:: GPT한테 시키자.

10. 해결 방법
    - 우선 Rank enum을 만들어서 enum으로 등수를 저장하자.
    - 비교 -> Map<Rank, Integer> 형태로 저장하자.
    - Map<Rank, Integer> -> Result 로 구현하자. 즉, 기존의 createResult를 두 단계로 쪼갰다.
    - 문제점: service가 이걸 정리하는 과정이 매우 불편하다. 별로 적절해 보이지 않는다.
      그렇다고 lotteries 라는 객체를 만들어서 걔가 lotto를 리스트로 들고, 
      lotto 묶음의 결과를 가지고 다니는건 적절한가?
    - 일단 지금 방식대로 하고 나중에 refactoring 해야 할 듯.
    - 이런 설계가 나온 배경은 하나의 도메인에 너무 많은 객체들이 있다. 또 생성하는 것에 솔직히 부담감을 느낀다.
    

11. 문제: controller의 역할 = 도메인 외부와 내부의 연결 + 흐름 관리